/**
 * @file ADC_Program.c
 * @author Khaled Abdulaziz 
 * @brief 
 * @version 0.1
 * @date 2023-04-04
 * 
 * 
 */

#include <util/delay.h>
#include "../../LIB/STD_TYPES.h"
#include "../../LIB/BIT_MATH.h"

#include "../DIO/DIO_Interface.h"
#include "../GIE/GIE_Interface.h"

#include "ADC_Interface.h"
#include "ADC_Private.h"
#include "ADC_Config.h"

void (*Global_pvoidCallBackADC) (void) = NULL;

void ADC_voidInit(void)
{

/* Select voltage reference and ADC input channels. We use the REFS0 and
REFS1 bits in the ADMUX register to select voltage reference and the
MUX4:0 bits in ADMUX to select the ADC input channel.  */

    #if ADC_VOLTAGE_REFERENCE == ADC_VREF_AREF_EXTERNAL
    CLEAR_BIT(ADC_ADMUX, ADMUX_REFS0);
    CLEAR_BIT(ADC_ADMUX, ADMUX_REFS1);
    #elif ADC_VOLTAGE_REFERENCE == ADC_VREF_AVCC
    SET_BIT(ADC_ADMUX, ADMUX_REFS0);
    CLEAR_BIT(ADC_ADMUX, ADMUX_REFS1);
    #elif ADC_VOLTAGE_REFERENCE == ADC_VREF_INTERNAL
    SET_BIT(ADC_ADMUX, ADMUX_REFS0);
    SET_BIT(ADC_ADMUX, ADMUX_REFS1);
    #endif

/*  Select the conversion speed. We use registers ADPS2:0 to select the conversion speed. */

    #if ADC_PRESCALER == ADC_PRESCALER_2
    CLEAR_BIT(ADC_ADCSRA, ADCSRA_ADPS0);
    CLEAR_BIT(ADC_ADCSRA, ADCSRA_ADPS1);
    CLEAR_BIT(ADC_ADCSRA, ADCSRA_ADPS2);

    #elif ADC_PRESCALER == ADC_PRESCALER_4
    CLEAR_BIT(ADC_ADCSRA, ADCSRA_ADPS0);
    SET_BIT(ADC_ADCSRA, ADCSRA_ADPS1);
    CLEAR_BIT(ADC_ADCSRA, ADCSRA_ADPS2);

    #elif ADC_PRESCALER == ADC_PRESCALER_8
    SET_BIT(ADC_ADCSRA, ADCSRA_ADPS0);
    SET_BIT(ADC_ADCSRA, ADCSRA_ADPS1);
    CLEAR_BIT(ADC_ADCSRA, ADCSRA_ADPS2);

    #elif ADC_PRESCALER == ADC_PRESCALER_16
    CLEAR_BIT(ADC_ADCSRA, ADCSRA_ADPS0);
    CLEAR_BIT(ADC_ADCSRA, ADCSRA_ADPS1);
    SETBIT(ADC_ADCSRA, ADCSRA_ADPS2);

    #elif ADC_PRESCALER == ADC_PRESCALER_32
    SET_BIT(ADC_ADCSRA, ADCSRA_ADPS0);
    CLEAR_BIT(ADC_ADCSRA, ADCSRA_ADPS1);
    SET_BIT(ADC_ADCSRA, ADCSRA_ADPS2);

    #elif ADC_PRESCALER == ADC_PRESCALER_64
    CLEAR_BIT(ADC_ADCSRA, ADCSRA_ADPS0);
    SET_BIT(ADC_ADCSRA, ADCSRA_ADPS1);
    SET_BIT(ADC_ADCSRA, ADCSRA_ADPS2);

    #elif ADC_PRESCALER == ADC_PRESCALER_128
    SET_BIT(ADC_ADCSRA, ADCSRA_ADPS0);
    SET_BIT(ADC_ADCSRA, ADCSRA_ADPS1);
    SET_BIT(ADC_ADCSRA, ADCSRA_ADPS2);
    #endif

    #if ADC_ADJUSTMENT == ADC_LEFT_ADJUST
    SET_BIT(ADC_ADMUX, ADMUX_ADLAR);
    #elif ADC_ADJUSTMENT == ADC_RIGHT_ADJUST
    CLEAR_BIT(ADC_ADMUX, ADMUX_ADLAR);
    #endif

/* 	// SET ADC CHANNEL

#if ADC_CHANNEL == ADC_SCM_ADC0
	CLEAR_BIT(ADC_ADMUX , ADMUX_MUX0);
	CLEAR_BIT(ADC_ADMUX , ADMUX_MUX1);
	CLEAR_BIT(ADC_ADMUX , ADMUX_MUX2);
	CLEAR_BIT(ADC_ADMUX , ADMUX_MUX3);
	CLEAR_BIT(ADC_ADMUX , ADMUX_MUX4);

#elif ADC_CHANNEL == ADC_SCM_ADC1
	SET_BIT(ADC_ADMUX , ADMUX_MUX0);
	CLEAR_BIT(ADC_ADMUX , ADMUX_MUX1);
	CLEAR_BIT(ADC_ADMUX , ADMUX_MUX2);
	CLEAR_BIT(ADC_ADMUX , ADMUX_MUX3);
	CLEAR_BIT(ADC_ADMUX , ADMUX_MUX4);

#elif ADC_CHANNEL == ADC_SCM_ADC2
	CLEAR_BIT(ADC_ADMUX , ADMUX_MUX0);
	SET_BIT(ADC_ADMUX , ADMUX_MUX1);
	CLEAR_BIT(ADC_ADMUX , ADMUX_MUX2);
	CLEAR_BIT(ADC_ADMUX , ADMUX_MUX3);
	CLEAR_BIT(ADC_ADMUX , ADMUX_MUX4);

#elif ADC_CHANNEL == ADC_SCM_ADC3
	SET_BIT(ADC_ADMUX , ADMUX_MUX0);
	SET_BIT(ADC_ADMUX , ADMUX_MUX1);
	CLEAR_BIT(ADC_ADMUX , ADMUX_MUX2);
	CLEAR_BIT(ADC_ADMUX , ADMUX_MUX3);
	CLEAR_BIT(ADC_ADMUX , ADMUX_MUX4);

#elif ADC_CHANNEL == ADC_SCM_ADC4
	CLEAR_BIT(ADC_ADMUX , ADMUX_MUX0);
	CLEAR_BIT(ADC_ADMUX , ADMUX_MUX1);
	SET_BIT(ADC_ADMUX , ADMUX_MUX2);
	CLEAR_BIT(ADC_ADMUX , ADMUX_MUX3);
	CLEAR_BIT(ADC_ADMUX , ADMUX_MUX4);

#elif ADC_CHANNEL == ADC_SCM_ADC5
	SET_BIT(ADC_ADMUX , ADMUX_MUX0);
	CLEAR_BIT(ADC_ADMUX , ADMUX_MUX1);
	SET_BIT(ADC_ADMUX , ADMUX_MUX2);
	CLEAR_BIT(ADC_ADMUX , ADMUX_MUX3);
	CLEAR_BIT(ADC_ADMUX , ADMUX_MUX4);

#elif ADC_CHANNEL == ADC_SCM_ADC6
	CLEAR_BIT(ADC_ADMUX , ADMUX_MUX0);
	SET_BIT(ADC_ADMUX , ADMUX_MUX1);
	SET_BIT(ADC_ADMUX , ADMUX_MUX2);
	CLEAR_BIT(ADC_ADMUX , ADMUX_MUX3);
	CLEAR_BIT(ADC_ADMUX , ADMUX_MUX4);

#elif ADC_CHANNEL == ADC_SCM_ADC7
	SET_BIT(ADC_ADMUX , ADMUX_MUX0);
	SET_BIT(ADC_ADMUX , ADMUX_MUX1);
	SET_BIT(ADC_ADMUX , ADMUX_MUX2);
	CLEAR_BIT(ADC_ADMUX , ADMUX_MUX3);
	CLEAR_BIT(ADC_ADMUX , ADMUX_MUX4);

#endif */

/*  ADC_FREE_RUNNING_MODE   0
    ADC_ANALOG_COMPARATOR   1
    ADC_EXTERNAL_INTERRUPT  2
    ADC_TIMER0_CTC          3
    ADC_TIMER0_OVF          4
    ADC_TIMER1_CTC          5
    ADC_TIMER1_OVF          6
    ADC_TIMER1_CE           7 */

    #if ADC_CONVERSION_MODE == ADC_SINGLE_CONVERSION_MODE
    CLEAR_BIT(ADC_ADCSRA, ADCSRA_ADATE);
    #elif  ADC_CONVERSION_MODE == ADC_FREE_RUNNING_INTERRUPT_MODE
    SET_BIT(ADC_ADCSRA, ADCSRA_ADATE);
        #if ADC_AUTO_TRIGGER_SOURCE == ADC_FREE_RUNNING_MODE
        CLEAR_BIT(ADC_SFIOR, SFIOR_ADTS0);
        CLEAR_BIT(ADC_SFIOR, SFIOR_ADTS1);
        CLEAR_BIT(ADC_SFIOR, SFIOR_ADTS2);
        #elif ADC_AUTO_TRIGGER_SOURCE == ADC_ANALOG_COMPARATOR
        SET_BIT(ADC_SFIOR, SFIOR_ADTS0);
        CLEAR_BIT(ADC_SFIOR, SFIOR_ADTS1);
        CLEAR_BIT(ADC_SFIOR, SFIOR_ADTS2);
        #elif ADC_AUTO_TRIGGER_SOURCE == ADC_EXTERNAL_INTERRUPT
        CLEAR_BIT(ADC_SFIOR, SFIOR_ADTS0);
        SET_BIT(ADC_SFIOR, SFIOR_ADTS1);
        CLEAR_BIT(ADC_SFIOR, SFIOR_ADTS2);
        #elif ADC_AUTO_TRIGGER_SOURCE == ADC_TIMER0_CTC
        SET_BIT(ADC_SFIOR, SFIOR_ADTS0);
        SET_BIT(ADC_SFIOR, SFIOR_ADTS1);
        CLEAR_BIT(ADC_SFIOR, SFIOR_ADTS2);
        #elif ADC_AUTO_TRIGGER_SOURCE == ADC_TIMER0_OVF
        CLEAR_BIT(ADC_SFIOR, SFIOR_ADTS0);
        CLEAR_BIT(ADC_SFIOR, SFIOR_ADTS1);
        ESET_BIT(ADC_SFIOR, SFIOR_ADTS2);
        #elif ADC_AUTO_TRIGGER_SOURCE == ADC_TIMER1_CTC
        SET_BIT(ADC_SFIOR, SFIOR_ADTS0);
        CLEAR_BIT(ADC_SFIOR, SFIOR_ADTS1);
        SET_BIT(ADC_SFIOR, SFIOR_ADTS2);
        #elif ADC_AUTO_TRIGGER_SOURCE == ADC_TIMER1_OVF
        CLEAR_BIT(ADC_SFIOR, SFIOR_ADTS0);
        SET_BIT(ADC_SFIOR, SFIOR_ADTS1);
        SET_BIT(ADC_SFIOR, SFIOR_ADTS2);
        #elif ADC_AUTO_TRIGGER_SOURCE == ADC_TIMER1_CE
        SET_BIT(ADC_SFIOR, SFIOR_ADTS0);
        SET_BIT(ADC_SFIOR, SFIOR_ADTS1);
        ESET_BIT(ADC_SFIOR, SFIOR_ADTS2);
        #endif

    #endif

    #if ADC_INTERRUPT == ADC_INTERRUPT_ENABLE
    SET_BIT(ADC_ADCSRA, ADCSRA_ADIE);
    #elif ADC_INTERRUPT == ADC_INTERRUPT_DISABLE
    CLEAR_BIT(ADC_ADCSRA, ADCSRA_ADIE);
    #endif

    //Turn on the ADC module of the AVR because it is disabled upon power-on reset to save power
    SET_BIT(ADC_ADCSRA, ADCSRA_ADEN);
}

u16  ADC_u16StartConversionPolling(u8 Copy_u8ChannelId)
{
    u16 Local_u16Result;
    //Seslect ADC Channel
    // for single ended input
    if(Copy_u8ChannelId >= ADC_SCM_ADC0 && Copy_u8ChannelId <= ADC_SCM_ADC7)
    {
        ADC_ADMUX &= ADMUX_MASK;
        ADC_ADMUX |= Copy_u8ChannelId;
    }

    SET_BIT(ADC_ADCSRA, ADCSRA_ADSC); //start conversion

    while(!GET_BIT(ADC_ADCSRA, ADCSRA_ADIF));//wait for conversion to finish
    
    SET_BIT(ADC_ADCSRA, ADCSRA_ADIF); // CLEAR THE FLAG BY WRITING 1 TO IT

    _delay_ms(1);

    #if ADC_PRESENTATION_ADJUSTMENT == ADC_RIGHT_ADJUSTMENT
	Local_u16Result = ADC_ADCL | (ADC_ADCH << 8);
    //Local_u16Result = ADC_DATA;
    #elif ADC_PRESENTATION_ADJUSTMENT == ADC_LEFT_ADJUSTMENT
	Local_u8Result = (ADC_ADCL >> 8) | (ADC_ADCH << 6);
    //Local_u16Result = (ADC_ADCH << 2);
    #endif

    return Local_u16Result;
}

u16  ADC_u16StartConversionInterrupt(u8 Copy_u8ChannelId)
{
    u16 Local_u16Result;

    //Select ADC Channel
    // for single ended input
    if(Copy_u8ChannelId >= ADC_SCM_ADC0 && Copy_u8ChannelId <= ADC_SCM_ADC7)
    {
        ADC_ADMUX &= ADMUX_MASK;
        ADC_ADMUX |= Copy_u8ChannelId;
    }

    SET_BIT(ADC_ADCSRA, ADCSRA_ADIE); // Enable Interrupt

    SET_BIT(ADC_ADCSRA, ADCSRA_ADSC); // start conversion

    #if ADC_PRESENTATION_ADJUSTMENT == ADC_RIGHT_ADJUSTMENT
	Local_u16Result = ADC_ADCL | (ADC_ADCH << 8);
    #elif ADC_PRESENTATION_ADJUSTMENT == ADC_LEFT_ADJUSTMENT
	Local_u16Result = (ADC_ADCL >> 8) | (ADC_ADCH << 6);
    #endif

    return Local_u16Result;
}

void ADC_voidSetADCCallBack(void (*Global_pvoidCallBack) (void))
{
	Global_pvoidCallBackADC = Global_pvoidCallBack;
}

ISR(__vector_16)
{
	if(Global_pvoidCallBackADC != NULL)
	{
		Global_pvoidCallBackADC();
	}
}
